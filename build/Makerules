# Copyright 2021 FLECS Technologies GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# forward build to Docker if DOCKERLESS is not set
ifndef DOCKERLESS
DOCKERARGS=-e DOCKERLESS=1 -e MAKEFLAGS="$(MAKEFLAGS)"
endif
%/all:
	$(DOCKER_PREFIX) $(MAKE) -C $(ROOT_DIR)/$* all
%/archive:
	$(DOCKER_PREFIX) $(MAKE) -C $(ROOT_DIR)/$* archive
%/binary:
	$(DOCKER_PREFIX) $(MAKE) -C $(ROOT_DIR)/$* binary
%/lib:
	$(DOCKER_PREFIX) $(MAKE) -C $(ROOT_DIR)/$* lib
%/package:
	$(DOCKER_PREFIX) $(MAKE) -C $(ROOT_DIR)/$* package
%/docker:
	$(MAKE) -C $(ROOT_DIR)/$* docker

# generic rule for building objects from source files
$(OUT)/%.o: src/%.cpp
	@mkdir -p $(shell readlink -m $(shell dirname $@))
	$(CXX) -c $(CXXFLAGS) -I $(ROOT_DIR) $(INCLUDE) -o $@ $<

# generic rule to build binary from objects, if set
ifdef BINARY
$(OUT)/$(BINARY): INCLUDE := $(INCLUDE_BINARY)
$(OUT)/$(BINARY): $(DEPENDS_BINARY) $(OBJ_BINARY) $(HEADER_BINARY)
	$(CXX) $(CXXFLAGS) -o $@ $(OBJ_BINARY) $(STATIC_LIBS_BINARY) $(DYNAMIC_LIBS_BINARY)

.PHONY: binary
binary: $(OUT)/$(BINARY)

ALL += binary
endif

# generic rule to build archive from objects, if set
ifdef ARCHIVE
$(OUT)/$(ARCHIVE): INCLUDE := $(INCLUDE_ARCHIVE)
$(OUT)/$(ARCHIVE): $(DEPENDS_ARCHIVE) $(OBJ_ARCHIVE) $(HEADER_ARCHIVE)
	$(AR) cr $@ $(OBJ_ARCHIVE)

.PHONY: archive
archive: $(OUT)/$(ARCHIVE)

ALL += archive
endif

# generic rule to build lib from objects, if set
ifdef LIB
$(OUT)/$(LIB): INCLUDE := $(INCLUDE_LIB)
$(OUT)/$(LIB): CXXFLAGS += -shared -fPIC
$(OUT)/$(LIB): $(DEPENDS_LIB) $(OBJ_LIB) $(HEADER_LIB)
	$(CXX) $(CXXFLAGS) -o $@ $(OBJ_LIB) $(STATIC_LIBS_LIB) $(DYNAMIC_LIBS_LIB)

.PHONY: lib
lib: $(OUT)/$(LIB)

ALL += lib
endif

# generic "all" rule - builds BINARY, LIB and ARCHIVE, if set
.PHONY: all
all: $(ALL)

# generic "deb-pkg" rule to build .deb package from artifacts
ifdef PACKAGE

pkg_copy_%:
	rm -rf $(OUT)/$(PKG_TYPE)
	mkdir -p $(shell readlink -m $(shell dirname $(TARGET)))
	[ -d pkg/$(PKG_TYPE) ] && cp -r pkg/$(PKG_TYPE) $(OUT)/$(PKG_TYPE) || true
	[ -d pkg/fs/ ] && cp -r pkg/fs/* $(OUT)/$(PKG_TYPE)/ || true
	cp -r $(ROOT_DIR)/build/pkg/$(PKG_TYPE)/* $(OUT)/$(PKG_TYPE)/

pkg_%:
	@if [ ! -z "$(BINARY)" ]; then \
		mkdir -p $(OUT)/$(PKG_TYPE)/usr/bin; \
		cp -pf $(OUT)/$(BINARY) $(OUT)/$(PKG_TYPE)/usr/bin; \
	fi;
	@if [ ! -z "$(ARCHIVE)" ]; then \
		mkdir -p $(OUT)/$(PKG_TYPE)/usr/lib; \
		cp -pf $(OUT)/$(ARCHIVE) $(OUT)/$(PKG_TYPE)/usr/lib; \
	fi;
	@if [ ! -z "$(LIB)" ]; then \
		mkdir -p $(OUT)/$(PKG_TYPE)/usr/lib; \
		cp -pf $(OUT)/$(LIB) $(OUT)/$(PKG_TYPE)/usr/lib; \
	fi;
	@sed -i "s/##ARCH##/$(ARCH)/g" $(OUT)/$(PKG_TYPE)/DEBIAN/control;
	@sed -i "s/##PACKAGE##/$(PACKAGE)/g" $(OUT)/$(PKG_TYPE)/DEBIAN/*;
	@sed -i "s/##VERSION##/$(VERSION)/g" $(OUT)/$(PKG_TYPE)/DEBIAN/*;
	@sed -i "s/##DESCRIPTION##/$(PACKAGE_DESC)/g" $(OUT)/$(PKG_TYPE)/DEBIAN/*;
	$(PKG_BUILD_CMD) $(PKG_BUILD_CMD_ARGS) $(OUT)/$(PKG_TYPE) $(TARGET)

DEB_PKG := $(PACKAGE)_$(VERSION)_$(ARCH).deb

$(OUT)/$(DEB_PKG): PKG_TYPE := debian
$(OUT)/$(DEB_PKG): PKG_BUILD_CMD := dpkg-deb --root-owner-group -Z gzip --build
$(OUT)/$(DEB_PKG): TARGET = $(OUT)/$(DEB_PKG)
$(OUT)/$(DEB_PKG): pkg_copy_deb deb-pkg-prepare pkg_deb

# allows targets additional preparation steps before packaging
.PHONY: deb-pkg-prepare

.PHONY: deb-pkg
deb-pkg: $(OUT)/$(DEB_PKG)

PACKAGES += deb-pkg

OPKG_PKG := $(PACKAGE)_$(VERSION)_$(ARCH).opk

$(OUT)/$(OPKG_PKG): PKG_TYPE := opkg
$(OUT)/$(OPKG_PKG): PKG_BUILD_CMD := opkg-build -c -o root -g root
$(OUT)/$(OPKG_PKG): TARGET = $(shell readlink -f $(OUT))
$(OUT)/$(OPKG_PKG): pkg_copy_opkg opkg-pkg-prepare pkg_opkg

# allows targets additional preparation steps before packaging
.PHONY: opkg-pkg-prepare

.PHONY: opkg-pkg
opkg-pkg: $(OUT)/$(OPKG_PKG)

PACKAGES += opkg-pkg
endif

ifndef NDEBUG
DOCKER_TAG := develop
else
DOCKER_TAG := latest
endif

ifdef DOCKER_IMAGE
.PHONY: docker
docker: docker-prepare
	docker buildx build \
		--push \
		--build-arg MACHINE=$(MACHINE) \
		--build-arg ARCH=$(ARCH) \
		--build-arg VERSION=$(VERSION) \
		--platform $(DOCKER_ARCH) \
		--tag $(DOCKER_IMAGE):$(ARCH)-$(DOCKER_TAG) .
	docker manifest rm $(DOCKER_IMAGE):$(DOCKER_TAG) || true
	docker manifest create $(DOCKER_IMAGE):$(DOCKER_TAG) \
		$(DOCKER_IMAGE):amd64-$(DOCKER_TAG) \
		$(DOCKER_IMAGE):armhf-$(DOCKER_TAG) \
		$(DOCKER_IMAGE):arm64-$(DOCKER_TAG)
	docker manifest push $(DOCKER_IMAGE):$(DOCKER_TAG)

.PHONY: docker-prepare
endif

# generic "package" rule to build all available packages
.PHONY: package
package: all $(PACKAGES)

# generic "clean" rule - remove $(OUT) directory
.PHONY: clean
clean:
	@rm -rf $(OUT)
